# Toy PO (Purchase Order) App

This is a toy PO (purchase order) app, written with FastAPI.
It is an end-to-end app using sqlite3 as its backend. ORM Models
are written with SQLAlchemy, and we also leverage Pydantic models
with FastAPI for automatic schema validation and autogenerated
OpenAPI documentation.

## Requirements

Only tested with Python 3.11 on ubuntu.

## Setup

We use pipenv to install dependencies (and also to run
developer workflow tasks, mentioned later). Poetry would
probably be a great option but I haven't gotten a chance to 
work with it yet.

Create a `.env` file, because this app is env-var configurable:
```
envsubst < ..env.example > .env
```

And install dependencies using pipenv:
```
pipenv install --dev
```

## Development

We store our development workflow tasks in our Pipfile. See
the `[scripts]` section of the Pipfile if you'd like to
run commands directly. In this way, you can activate the Pipenv
virtual environment and shell and run commands yourself:

```bash
# Example of using autopep8 directly
pipenv shell
# wait until shell is loaded, then run
autopep8 --in-place --recursive toypo
```

For ease of use though, here are the predetermined
developer workflow tasks. I recommend using these
most of the time.

* ```
  pipenv run app
  ```
  Start a local webserver on port 8000
* ```
  pipenv run autoformat
  ```
  Run autopep8 autoformatter
* ```
  pipenv run lint
  ```
  Run pylint
* ```
  pipenv run test
  ```
  Run unit tests. A sqlite3 test DB file is created temporarily,
  but should be removed when tests are completed.

## RESTful API Documentation

To view autogenerated documentation, start the app
and then go to http://localhost:8000/docs. You'll see
operations such as `GET /purchase_orders/` all listed
out there.

FastAPI builds and serves these OpenAPI docs as a
first-class feature of the service, and documentation
is shown by default. This works well for internal services,
but external services would require better authentication.

To see the code which aligns with the OpenAPI documentation,
go to toypo/main.py first. There is all the application
endpoints that we handle with our FastAPI application.

## Code Internals

Most of the code is broken up into 5 modules.

### Application (main.py)

This is the core web application. We set up routes
here, inject resources (like the database), and
would do more middleware configuration if necessary
here as well.

We merge data together from the item inventory
and PO database in these route callbacks. Lower-level
data operations are handled in the CRUD module.

### CRUD (crud.py)

Our CRUD (Create, Read, Update, Delete) handles all
PO data operations. If a relation is created
(i.e. we create a PO associated with a PA) we do
validation at this layer.

This module makes heavy use of SQLAlchemy's queries.

### Pydantic schemas/models (schemas.py)

We use Pydantic to explicitly map Python objects
to/from JSON and the SQLAlchemy models. In our pydantic
schemas we are giving structure to our RESTful
requests and responses.

FastAPI shows Pydantic examples in the autogenerated
docs, for user/developers to start learning the
API interface quickly.

### SQLAlchemy models (models.py)

Our SQLAlchemy models are defined here. Defining our
ORMs should be relatively self-explanatory.

We have a PO, and a PA, with a many:1 relationship
between them. PO's can also exist without a PA.

For now, PO's can also have a single kind of item.
This is just to keep focus on the PO and PA creation
and relation, and not so much on orders and items.
In a real scenario PO's can include many kinds of
items, but that order information may be stored
in another service anyways (in which case this
microservice may just store an order_id instead of
an item_id and call it done).

### Item Inventory (inventory.py)

So I went with a super quick-and-dirty item inventory,
you can view it at ./toypo/inventory.py. The reason
it's so basic (and contains stubbed data, directly
in the module!) is that I'm assuming the real item
inventory exists elsewhere. So I built it as minimal
as possible, while still providing the functionality needed
for Purchase Order operations.
